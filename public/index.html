<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>notes on c2</title> 

  <link rel="stylesheet" href="highlight/styles/ascetic.css">
  </head>
<style>
.chart {
  font: 10px sans-serif;
  shape-rendering: crispEdges;
}
.chart rect {
  stroke : white;
  fill : steelblue; /* magnum? */
}
.chart text{
  fill : white;
}
.chart text.rule{
  fill : black;
}

pre {
  margin: 0.5em;
}

p {
  width: 42em;
}

.output {
  border : 1px solid #eee;
  width: 42em;
  padding: 0.5em;
  margin: 0.5em;
}

.ex6 .chart {
  height : 100px;
  position: relative;
}

.col {
  display :inline-block;
  width : 20px;
  background-color: steelblue;
  transition: height 400ms ease;
  border: 1px solid white;
  position : absolute;
  bottom : 0px;
}
</style>
  <body>
  <header>
    <h1>cover tracks</h2>
    <p>ClojureScript on "A Bar Chart, Part 1"</p>
  </header>

  <!--
  Things to cover.

  Why I'm looking at c2?
    - attraction of clojurescript
    - experience with d3
    - possibility of client/server rendered views
    - fun

  Basics of c2
    - what it says it is
    - ex1, as an example of bind!
    - ex1 with generated vectors

  Unify
    - demonstrate object consistency with unify

  Cover Track
    - explain target: Bostock's A Bar Chart, Part 1
    - build bars
    - label bars
    - add grid-lines
    - "Et voilÃ !"
 
  Wrap up
  -->


  <h2>intro</h2>

  <p>Working as a client side developer there have been scant opportunities for
  me to pursue a passion and use lisp in earnest.  ClojureScript has
  unequivocally removed that obstacle, by bringing a modern and powerful lisp
  to javascript environments.</p>
  
  <p>At a glance, Clojure, a predominately functional language might not seem
  like a natural fit for client side development.  Much of the discussion in
  the javascript community seems to focus on mutable models, and finding ways
  to listen for changes in those model. Could Clojure excel in these muddy
  state driven waters?</p>

  <p>Not so long ago I might have thought it difficult. Then I discovered d3.
  Mike Bostocks d3 is (awesome) a javascript library for manipulating
  documents, but what makes it unique is its focus on "transformation not
  representation" which all sounds very functional!  I've been building
  applications with d3 for a couple of years now, and have seen a more
  functional style of architecture reap many benefits, even when constrained by
  the naturally imperative browser environment.</p> 

  <p>To get a feel for what building applications in clojurescript is like I've
  been doing a series of cover tracks (copying things already built).  Recently
  I've been focusing on a library called c2, which is heavily inspired by d3
  but also takes many cues from clojure to give a idiomatic experience.</p>

  
  <h2>c2 basics</h2>

  <p>Before jumping in and trying to cover one of Mikes demos its worth going
  over the basics of c2.  Take a look at how to generate a simple ordered-list
  using c2.</p>

  <pre>
  <code class="clojure">
(bind! ".ex-basic"  
  [:div
   [:ol
     [:li "wibble"]
     [:li "wobble"]
     [:li "woooo"]]])
  </code>
  </pre>

  <p>The code is almost alarmingly simple, when I first saw it I assumed
  there was something nasty waiting for me round the corner, things cant be 
  this straight forward right?</p>

  <p>Breaking it down at little there is a call to a function named
  <code>bind!</code>, (the "!" indicates there are side effects) which takes
  two parameters, a string css selector and a vector representing the desired
  dom structure.</p>

  <p><code>bind!</code> takes care of ensuring that the dom under the selector
  matches the structure of the vector.  Heres the output.</p>
  
  <div class="ex-basic output"></div>

  <p>Its worth taking a moment to understand how this simple example works.
  The <code>bind!</code> function finds the desired target node from the css
  selector then walks the dom under that node ensuring it matches the vector
  provided.  It doesnt set innerHTML, it updates what it finds in place to match
  the desired state.</p>

  <p>Its not often we have a complete picture of what dom structure we want
  when we are authoring the code. In d3 rather than building each
  <code>li</code> element and setting the copy by hand we would bind some data
  to an expression which would generate each node based on a datum.</p>

  <pre> <code class="javascript">
var sel = d3.select("ol")
  .selectAll("li")
  .data(["wibble", "wobble", "woooo"])

sel.enter().append("li").text(String)
  </code> </pre>

  <p>Let take a look at how we could achieve the same thing in c2 and
  clojurescript.</p>

  <pre>
  <code class="clojure">
(bind! ".ex-basic"  
  [:div
   [:ol
     (map (fn [d] [:li d]) ["wibble" "wobble" "wo"])]])
  </code>
  </pre>

  <p>From the perspective of c2, nothing has changed.  We are still parsing
  a fully formed vector to the <code>bind!</code> method, only this time we
  have generated the <code>:li</code> vectors on the fly using clojures
  <code>map</code> function.  This seemingly simple change is very powerful,
  since we can run multiple <code>map</code> expressions, or anything else from
  clojures rich arsenal of functions to generate the desired dom structure.
  Also, we are no longer in the position of forcing all that data into an array
  bound to a top level node.  We can use any data we have to hand at any point
  in the data structures hierarchy.
  
  <h2>the cover track</h2>


  <div class="ex4"></div>
  <div class="ex5"></div>

  <div class="output">
    <button id="btn-poke">poke</button>
    <button id="btn-reset">reset</button>
    <div class="ex-keys"></div>
  </div>

  <div class="ex6"></div>
  <script type="text/javascript" src="sketch-dev.js"></script>
  <script src="highlight/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</body>
</html>
