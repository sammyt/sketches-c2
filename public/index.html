<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>notes on c2</title> 

  <link rel="stylesheet" href="highlight/styles/ascetic.css">
  </head>
<style>
body {
  padding-left : 15%;
}
.chart {
  font: 10px sans-serif;
  shape-rendering: crispEdges;
}
.chart rect {
  stroke : white;
  fill : steelblue; /* magnum? */
}
.chart text{
  fill : white;
}
.chart text.rule{
  fill : black;
}

pre {
  margin: 0.5em;
}

p {
  width: 40em;
}

aside {
  margin-left: 2em;
  width : 36em;
}

.output {
  border : 2px solid #eee;
  width: 40em;
  padding: 0.5em;
  margin: 0.5em;
}

.ex6 .chart {
  height : 100px;
  position: relative;
}

.col {
  display :inline-block;
  width : 20px;
  background-color: steelblue;
  transition: height 400ms ease;
  border: 1px solid white;
  position : absolute;
  bottom : 0px;
}
</style>
  <body>
  <header>
    <h1>Cover Tracks</h2>
    <p>ClojureScript on "A Bar Chart, Part 1"</p>
  </header>

  <!--
  Things to cover.

  Why I'm looking at c2?
    - attraction of clojurescript
    - experience with d3
    - possibility of client/server rendered views
    - fun

  Basics of c2
    - what it says it is
    - ex1, as an example of bind!
    - ex1 with generated vectors

  Unify
    - demonstrate object consistency with unify

  Cover Track
    - explain target: Bostock's A Bar Chart, Part 1
    - build bars
    - label bars
    - add grid-lines
    - "Et voilÃ !"
 
  Wrap up
  -->

  <p>Working as a client side developer there have been scant opportunities for
  me to pursue a passion and use lisp in earnest.  ClojureScript has
  unequivocally removed that obstacle, by bringing a modern and powerful lisp
  to javascript environments.</p>
  
  <p>At a glance, Clojure, a predominately functional language might not seem
  like a natural fit for client side development.  Much of the discussion in
  the javascript community seems to focus on mutable models, and finding ways
  to listen for changes in those models.  But despite the inevitability of state
  in the client a more functional approach to design can reap many rewards.</p>

  <p>I have been coding fully fledged client side applications in a functional
  style for a couple of years now.  With significant influence taken from
  libraries like Mick Bostocks awesome d3.  d3 talks about focusing on
  transformation not representation in contrast to much of the standard
  approach to UI construction.  I am excited about how a language with
  functional roots could further influence the way I design and think.</p> 
  
  <p>To get a feel for what building applications in clojurescript is like I've
  been doing a series of cover tracks (copying things already built).  Recently
  I've been focusing on a library called c2, which is heavily inspired by d3
  but also takes many cues from clojure to give a idiomatic experience.</p>

  <h2>c2 basics</h2>

  <p>Before jumping in and trying to cover one of Mikes d3 demos its worth
  going over the basics of c2 to get a sense for its API.  Take a look at how
  to generate a simple ordered-list.</p>

  <pre>
  <code class="clojure">
(bind! ".ex-basic"  
  [:div
   [:ol
     [:li "wibble"]
     [:li "wobble"]
     [:li "woooo"]]])
  </code>
  </pre>

  <p>The code is almost alarmingly simple, when I first saw it I assumed
  there was something nasty waiting for me round the corner, things cant be 
  this straight forward right?</p>

  <p>Breaking it down at little there is a call to a function named
  <code>bind!</code>, (the "!" indicates there are side effects) which takes
  two parameters, a string css selector and a vector representing the desired
  dom structure.</p>

  <p><code>bind!</code> takes care of ensuring that the dom under the selector
  matches the structure of the vector.  Heres the output.</p>
  
  <div class="ex-basic output"></div>

  <p>Its worth taking a moment to understand how this simple example works.
  The <code>bind!</code> function finds the desired target node from the css
  selector, then walks the dom under that node ensuring it matches the vector
  provided.  It doesnt set innerHTML, it updates what it finds in place to match
  the desired state.</p>

  <p>Its not often we have a complete picture of the dom structure we want when
  we are authoring the code. In d3 rather than building each <code>li</code>
  element and setting the copy by hand we would bind some data to an expression
  which would generate each node based on a datum.</p>

  <pre> <code class="javascript">
var sel = d3.select("ol")
  .selectAll("li")
  .data(["wibble", "wobble", "woooo"])

sel.enter().append("li").text(String)
  </code> </pre>

  <p>Take a look at how we could achieve the same thing in c2 and
  clojurescript.</p>

  <pre>
  <code class="clojure">
(bind! ".ex-basic"  
  [:div
   [:ol
     (map (fn [d] [:li d]) ["wibble" "wobble" "woooo"])]])
  </code>
  </pre>

  <p>From the perspective of c2, nothing has changed.  We are still parsing
  a fully formed vector to the <code>bind!</code> method, only this time we
  have generated the <code>:li</code> vectors on the fly using clojures
  <code>map</code> function.  This seemingly simple change is very powerful,
  since we can run multiple <code>map</code> expressions, or anything else from
  clojures rich arsenal of functions to generate the desired dom structure.
  Also, we are no longer in the position of forcing all that data into an array
  bound to a top level node.  We can use any data we have to hand at any point
  in the data structures hierarchy.

  
  <h2>Covering a d3 chart</h2>

  <p>Cover tracks are a nice way to get an idea of how a technology feels to
  work with, since you have a clear goal and a benchmark in complexity to view
  your solution in the light of. I'm covering a very simple d3 example here,
  but in doing so I got a great feel for using the language, tools and
  library.</p>

  <p>Take a look at the chart, and the required code in the <a
    href="http://mbostock.github.io/d3/tutorial/bar-1.html">Mikes original</a>.</p>

  <aside>As a quick aside, if you haven't come across d3 before then stop
    reading and devote whatever super valuable time you were giving to this
    article to reading about d3!  I think its one of the most original and
    elegant pieces of work I've seen for building visual interfaces.</aside>

  <p>The chart built with d3 has a simple structure, where each of the 
  elements (</p>

  <div class="ex-bars output"></div>

<pre><code class="clojure">
(bind! ".ex-bars"
  (let [data [4, 8, 15]
        width 200 
        height 60
        bar-height 20
        scale-x (scale/linear 
                  :domain [0 (apply max data)] 
                  :range  [0 width])]

    [:div [:div.chart
     [:svg {:width width, :height height}
     
      (map-indexed (fn [i d]
        [:rect {:width (scale-x d) 
                :height bar-height, 
                :y (* i bar-height)}]) data)]]]))
</code></pre>


  <div class="ex5 output"></div>

  <div class="output">
    <button id="btn-poke">poke</button>
    <button id="btn-reset">reset</button>
    <div class="ex-keys"></div>
  </div>

  <div class="ex6 output"></div>
  <script type="text/javascript" src="sketch-dev.js"></script>
  <script src="highlight/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</body>
</html>
